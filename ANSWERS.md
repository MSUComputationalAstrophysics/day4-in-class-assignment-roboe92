Answers to ica4:

1. When I compared the errors for the three methods, I found that the Midpoint method had smaller error than the Euler method and the Runge-Kutta method. The decrease in error between the three methods is magnified as the time step is decresed. That is, the Runge-Kutta and Midpoint methods get more orders of magnitude smaller error than Euler as time step decreases (see ica4_c.png).

2. I set my threshhold in error to be less than 1% over the time domain from 0 to 4$\pi$. For the Euler method, I needed a step size of 0.0001$\pi$ to reach the desired threhhold, and it took ~16000 floating point operations to get there. For the Midpoint method, I needed a step size of 0.05$\pi$ to reach the desired threshhold and it took ~870 floating point operations. Finally, the Runge-Kutta method only needed a step size of 0.2$\pi$ in order to reach the desired threshhold and took 589 floating point operations. 

	 For the sake of interest, I decided to compare the performance of the Runge- Kutta method and the midpoint method for smaller step size ($\delta\mathrm{t}=0.001\pi$), and I found that while the Runge-Kutta method had about 6 orders of magnitide smaller error, it had to do ~124,000 floating point operations compared to ~44,000 that the Midpoint method needed. For a case this simple, the Midpoint method can still outpace the Runge-Kutta method for small step sizes because of the number of operations it does. If I increase the step size for Runge-Kutta to $\delta\mathrm{t}=0.003\pi$, then I get approximately the same number of floating point operations as it takes for the Midpoint method for the step size of $\delta\mathrm{t}=0.001\pi$.